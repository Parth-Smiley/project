<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chat - Doctor</title>
  <style>
    body {
      margin:0;
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #f0f7ff 0%, #e6f2ff 100%);
    }
    .container { display:flex; height:100vh; }
    .sidebar {
      width:280px; background:#fff;
      border-right:1px solid #ddd;
      display:flex; flex-direction:column;
    }
    .sidebar h2 {
      padding:20px; margin:0;
      background: linear-gradient(to right, #2c7dff, #00b8ff);
      color:#fff; font-size:20px; font-weight:600;
    }
    .contact {
      position: relative;
      padding: 15px 20px;
      border-bottom: 1px solid #f0f0f0;
      text-decoration: none;
      color: #333;
      display: block;
    }
    .contact.unread::after {
      content: '';
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      width: 10px;
      height: 10px;
      background: #2c7dff;
      border-radius: 50%;
    }
    .contact:hover { background:#f7faff; }
    .contact.active { background:#e6f0ff; font-weight:600; }
    .chat-window { flex:1; display:flex; flex-direction:column; }
    .chat-header {
      padding:18px 20px;
      background:#fff;
      border-bottom:1px solid #ddd;
      font-weight:600;
      font-size:18px;
      color:#2c7dff;
      box-shadow:0 2px 6px rgba(0,0,0,0.05);
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .chat-header .call-btn {
      background:linear-gradient(to right, #2c7dff, #00b8ff);
      color:#fff;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }
    .chat-box {
      flex:1; padding:20px;
      overflow-y:auto;
      background:#f4f8ff;
      display:flex; flex-direction:column;
    }
    .msg {
      margin:8px 0;
      padding:12px 16px;
      border-radius:18px;
      max-width:65%;
      box-shadow:0 2px 5px rgba(0,0,0,0.05);
    }
    .msg.doctor {
      background: linear-gradient(to right, #2c7dff, #00b8ff);
      color:#fff;
      align-self:flex-end;
      border-bottom-right-radius:5px;
    }
    .msg.patient {
      background:#fff;
      align-self:flex-start;
      border-bottom-left-radius:5px;
    }
    .form-box {
      display:flex;
      padding:15px;
      background:#fff;
      border-top:1px solid #ddd;
    }
    .form-box input {
      flex:1;
      padding:12px 15px;
      border:1px solid #ccc;
      border-radius:25px;
      outline:none;
      font-size:15px;
    }
    .form-box button {
      margin-left:10px;
      padding:12px 20px;
      border:none;
      border-radius:25px;
      background:linear-gradient(to right, #2c7dff, #00b8ff);
      color:#fff;
      font-weight:600;
      cursor:pointer;
      transition:0.2s;
    }
    .form-box button:hover { opacity:0.9; }

    /* Modals */
    .modal {
      display: none; position: fixed; top:0; left:0; right:0; bottom:0;
      background: rgba(0,0,0,0.85); justify-content:center; align-items:center; flex-direction:column;
      z-index:1000; color:#fff;
    }
    .modal-content { background:#2c7dff; padding:20px; border-radius:10px; text-align:center; }
    .modal-content button { margin:10px; padding:10px 20px; border:none; border-radius:6px; font-weight:600; cursor:pointer; }
    .btn.accept { background:#00c853; color:white; }
    .btn.decline { background:#d32f2f; color:white; }
    #videoCallModal video { width:40%; margin:10px; border-radius:10px; background:black; }
    .end-call { margin-top:15px; background:#d32f2f; color:white; border:none; padding:12px; border-radius:50%; }
    .video-preview { display:flex; gap:10px; align-items:center; justify-content:center; }
  </style>
</head>
<body>
  <!-- Incoming Call Popup -->
  <div id="incomingCallModal" class="modal">
    <div class="modal-content">
      <p id="callerName" style="font-size:20px; margin-bottom:12px;"></p>
      <button class="btn accept" onclick="acceptCall()">Accept</button>
      <button class="btn decline" onclick="declineCall()">Decline</button>
    </div>
  </div>

  <!-- Video Call Modal -->
  <div id="videoCallModal" class="modal">
    <div class="video-preview">
      <video id="remoteVideo" autoplay playsinline></video>
      <video id="localVideo" autoplay playsinline muted style="width:150px; height:auto; border-radius:8px;"></video>
    </div>
    <button class="end-call" onclick="endCall()">End</button>
  </div>

  <div class="container">
    <!-- Sidebar -->
    <div class="sidebar">
      <h2>Patients</h2>
      {% for patient in patients %}
        <a class="contact {% if active_patient == patient %}active{% endif %}"
           href="{{ url_for('doctor_dashboard') }}?patient={{ patient|urlencode }}">
          {{ patient }}
        </a>
      {% endfor %}
    </div>

    <!-- Chat Window -->
    <div class="chat-window">
      {% if active_patient %}
        <div class="chat-header">
          <div>Chat with {{ active_patient }}</div>
          <div>
            <button class="call-btn" onclick="startCall('{{ active_patient }}')">ðŸ“¹ Call</button>
          </div>
        </div>

        <div class="chat-box" id="chat-box">
          {% for msg in messages %}
            <div class="msg {{ msg.sender }}">
              {% if msg.sender == 'doctor' %}You: {{ msg.text }}
              {% else %}{{ active_patient }}: {{ msg.text }}{% endif %}
            </div>
          {% endfor %}
        </div>

        <form method="POST" class="form-box">
          <input type="text" name="message" placeholder="Type a message..." required>
          <button type="submit">Send</button>
        </form>
      {% else %}
        <div class="chat-header">Select a patient to start chatting</div>
      {% endif %}
    </div>
  </div>

  <!-- Socket.IO client -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
/* ======= Robust WebRTC client for doctor_dashboard.html ======= */

const socket = io();
socket.emit("join", { username: "{{ username }}" });
console.log("[webrtc] Doctor joined as", "{{ username }}");

let localStream = null;
let pc = null;
let currentPeer = null;
let lastOffer = null;
let remoteDescSet = false;
let pendingRemoteCandidates = [];

// Use STUN + TURN
const servers = {
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" },
    { urls: "turn:openrelay.metered.ca:80", username: "openrelayproject", credential: "openrelayproject" }
  ]
};

function showModal(id){ document.getElementById(id).style.display = "flex"; }
function hideModal(id){ document.getElementById(id).style.display = "none"; }

const remoteVideo = document.getElementById("remoteVideo");
const localVideo  = document.getElementById("localVideo");
if (remoteVideo) { remoteVideo.autoplay = true; remoteVideo.playsInline = true; }
if (localVideo)  { localVideo.autoplay = true; localVideo.playsInline = true; localVideo.muted = true; }

function createPeerConnection(remoteUser) {
  pc = new RTCPeerConnection(servers);
  remoteDescSet = false;
  pendingRemoteCandidates = [];

  pc.onicecandidate = e => {
    if (e.candidate) {
      console.log("[webrtc] sending ICE to", remoteUser);
      socket.emit("ice_candidate", { candidate: e.candidate, to: remoteUser });
    }
  };

  pc.ontrack = e => {
  console.log("[webrtc] got remote track", e.streams[0]);
  if (remoteVideo) {
    remoteVideo.srcObject = e.streams[0];
    remoteVideo.play().catch(err => {
      console.warn("[webrtc] autoplay blocked for remoteVideo:", err);
    });
  }
};

  pc.onconnectionstatechange = () => {
    console.log("[webrtc] connection state:", pc.connectionState);
  };

  return pc;
}

// Caller (doctor) starts a call
async function startCall(toUser) {
  console.log("[webrtc] startCall ->", toUser);
  currentPeer = toUser;

  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
if (localVideo) {
  localVideo.srcObject = localStream;
  localVideo.play().catch(err => {
    console.warn("[webrtc] autoplay blocked for localVideo:", err);
  });
}
  } catch (err) {
    console.error("getUserMedia error", err);
    alert("Cannot access camera/mic");
    return;
  }

  pc = createPeerConnection(toUser);
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  console.log("[webrtc] sending offer to", toUser);
  showModal("videoCallModal");
  socket.emit("call_offer", { offer, from: "{{ username }}", to: toUser });
}

// Incoming call
socket.on("incoming_call", data => {
  console.log("[webrtc] incoming_call", data);
  lastOffer = data.offer;
  currentPeer = data.from;
  document.getElementById("callerName").innerText = "Incoming call from " + currentPeer;
  showModal("incomingCallModal");
});

// Accept incoming call
async function acceptCall() {
  hideModal("incomingCallModal");
  console.log("[webrtc] acceptCall from", currentPeer);

  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
    if (localVideo) localVideo.srcObject = localStream;
  } catch (err) {
    console.error("getUserMedia error", err);
    alert("Cannot access camera/mic");
    return;
  }

  pc = createPeerConnection(currentPeer);
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  if (!lastOffer) {
    console.error("No offer present on accept");
    return;
  }

  await pc.setRemoteDescription(new RTCSessionDescription(lastOffer));
  remoteDescSet = true;

  // flush queued ICE
  for (const c of pendingRemoteCandidates) {
    try { await pc.addIceCandidate(new RTCIceCandidate(c)); }
    catch(err){ console.warn("Failed to add queued ICE", err); }
  }
  pendingRemoteCandidates = [];

  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  console.log("[webrtc] sending answer to", currentPeer);
  socket.emit("call_answer", { answer, from: "{{ username }}", to: currentPeer });

  showModal("videoCallModal");
}

// Decline call
function declineCall() {
  hideModal("incomingCallModal");
  if (currentPeer) socket.emit("call_decline", { from: "{{ username }}", to: currentPeer });
  currentPeer = null;
  lastOffer = null;
}

// Caller receives answer
socket.on("call_answer", async data => {
  console.log("[webrtc] got call_answer", data);
  if (!pc) return;
  await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
  remoteDescSet = true;
  for (const c of pendingRemoteCandidates) {
    try { await pc.addIceCandidate(new RTCIceCandidate(c)); }
    catch(err){ console.warn("Failed to add queued ICE", err); }
  }
  pendingRemoteCandidates = [];
  showModal("videoCallModal");
});

// Handle ICE
socket.on("ice_candidate", async data => {
  console.log("[webrtc] got ICE candidate", data);
  if (!data || !data.candidate) return;
  if (pc && remoteDescSet) {
    try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); }
    catch (e) { console.error("addIceCandidate error", e); }
  } else {
    console.log("[webrtc] queuing ICE (remote desc not set yet)");
    pendingRemoteCandidates.push(data.candidate);
  }
});

// Decline / End
socket.on("call_decline", () => { alert("Call declined"); endCall(); });
socket.on("call_end", () => { endCall(); });

function endCall() {
  console.log("[webrtc] endCall");
  if (pc) { try { pc.close(); } catch(e){} pc = null; }
  if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
  hideModal("videoCallModal");
  if (currentPeer) socket.emit("call_end", { from: "{{ username }}", to: currentPeer });
  currentPeer = null;
  lastOffer = null;
}
</script>


</body>
</html>
